"""Test suite for python decompiler library."""

import datetime
import importlib
import os.path
import random
import tempfile
import unittest

import xdis.magics

from azul_plugin_python_decompiler.decompiler.python_decompiler import (
    decompile,
    decompile_file,
)

test_script = 'print("Hello testing world!")'
test_script_name = "hello.py"
test_precompiled_name = os.path.join("bytecode", "hello.cpython-37.pyc")
test_precompiled_py310_name = os.path.join("bytecode", "dummy_file.cpython-310.pyc")


class PyDecompile310Test(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        """Set up data required for testing."""
        cls.pyc_path = os.path.join(os.path.dirname(__file__), test_precompiled_py310_name)

    def test_fail_to_decompile(self):
        """Test that fails to decompile the python code due to uncompyle6 lack of support."""
        with open(self.pyc_path, "rb") as f:
            results = decompile(f.read())
            self.assertGreaterEqual(len(results.keys()), 2)
            self.assertIn("error_msg", results)
            self.assertIn("Unsupported Python version", results.get("error_msg"))

    def test_fail_to_decompile_file(self):
        results = decompile_file(self.pyc_path)
        self.assertGreaterEqual(len(results.keys()), 2)
        self.assertIn("error_msg", results)
        self.assertIn("Unsupported Python version", results.get("error_msg"))


class PyDecTest(unittest.TestCase):
    """Test class for python_decompiler."""

    @classmethod
    def setUpClass(cls):
        """Set up data required for testing."""
        # Note: due to uncompyle6 lack of python 3.9 support (our new default)
        # we no longer generate the pyc during testing.
        # A precompiled python3.7 version of the test script is now included.
        cls.pyc_path = os.path.join(os.path.dirname(__file__), test_precompiled_name)

        # read .pyc bytecode into memory
        with open(cls.pyc_path, "rb") as f:
            cls.hello_pyc = f.read()

        test_array = bytearray()
        random.seed()
        for _ in range(256):
            test_array.append(random.randint(0, 255))  # noqa: S311

        cls.random_bytes = bytes(test_array)

        cls.fake_pyc = bytes(importlib.util.MAGIC_NUMBER + cls.random_bytes)

        # replace bytecode header with one from different version and test
        # Put python 2.7 header onto 3.x code i.e. .pyc header is 16 bytes
        cls.misversioned = xdis.magics.int2magic(62211) + cls.hello_pyc[16:]

    def test_random_bytes(self):
        """Test with randomly generated bytes."""
        results = decompile(self.random_bytes)

        # results only contains an error from Input
        self.assertIn("error_msg", results)
        self.assertIn("Unknown magic number", results["error_msg"])

        # error caused due to input
        self.assertIn("error_type", results)
        self.assertEqual(results["error_type"], "Input")

        # only the error keys
        self.assertEqual(len(results.keys()), 2)

    def test_header_with_random_bytes(self):
        """Test with random bytes prepended with this Python version's magic number."""
        # xdis raises ValueError, displays error message to stderr
        results = decompile(self.fake_pyc)

        self.assertIn("error_msg", results)
        self.assertEqual(results["error_msg"].split("\n")[0], "Traceback (most recent call last):")

        # error caused due to input
        self.assertIn("error_type", results)
        self.assertEqual(results["error_type"], "Input")

        # only the error keys
        self.assertEqual(len(results.keys()), 2)

    def test_hello_with_wrong_header(self):
        """Test compiled hello world with .pyc header replaced from that of Python 2.x."""
        # xdis raises AttributeError, displays error message to stderr
        results = decompile(self.misversioned)

        self.assertIn("error_msg", results)
        self.assertTrue("Unknown type" in results["error_msg"])

        # error caused due to input
        self.assertIn("error_type", results)
        self.assertEqual(results["error_type"], "Input")

        # only the error keys
        self.assertEqual(len(results.keys()), 2)

    def test_simple(self):
        """Test compiled hello world."""
        results = decompile(self.hello_pyc)

        # filename should match that of compiled file
        self.assertEqual(results["filename"], "hello.py")

        # version string
        self.assertEqual(results["version"], 3.7)

        # magic must match that of is this python version
        self.assertEqual(results["magic"], 3394)

        # test that source code matches
        # need to convert double quotes to single
        self.assertIn(bytes(test_script, "utf-8"), results["source"])

        self.assertEqual(results["timestamp"], datetime.datetime(2021, 5, 7, 1, 54, 19))

    def test_simple_decompile_file(self):
        """Test compiled hello world."""
        results = decompile_file(self.pyc_path)

        # filename should match that of compiled file
        self.assertEqual(results["filename"], "hello.py")

        # version string
        self.assertEqual(results["version"], 3.7)

        # magic must match that of is this python version
        self.assertEqual(results["magic"], 3394)

        # test that source code matches
        # need to convert double quotes to single
        self.assertIn(bytes(test_script, "utf-8"), results["source"])

        self.assertEqual(results["timestamp"], datetime.datetime(2021, 5, 7, 1, 54, 19))

    def test_simple_decompile_file_bad_extension(self):
        """Test compiled hello world."""
        with tempfile.NamedTemporaryFile() as pyc_no_ext_file:
            with open(self.pyc_path, "rb") as f:
                pyc_no_ext_file.write(f.read())
            pyc_no_ext_file.seek(0)

            results = decompile_file(pyc_no_ext_file.name)

            # verify symlink is removed.
            self.assertTrue(not os.path.exists(pyc_no_ext_file.name + ".pyc"))

            # filename should match that of compiled file
            self.assertEqual(results["filename"], "hello.py")

            # version string
            self.assertEqual(results["version"], 3.7)

            # magic must match that of is this python version
            self.assertEqual(results["magic"], 3394)

            # test that source code matches
            # need to convert double quotes to single
            self.assertIn(bytes(test_script, "utf-8"), results["source"])

            self.assertEqual(results["timestamp"], datetime.datetime(2021, 5, 7, 1, 54, 19))
